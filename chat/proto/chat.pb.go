// Code generated by protoc-gen-go.
// source: chat.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	chat.proto

It has these top-level messages:
	LoginRequest
	LogoutResponse
	User
	Credentials
	ListUsersResponse
	PrivateMsgRequest
	PublicMsgRequest
	SendMsgResponse
	ChatServerMsg
	PrivateMsg
	PublicMsg
	UserEvent
	Heartbeat
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type UserEvent_EventType int32

const (
	UserEvent_UNKNOWN UserEvent_EventType = 0
	UserEvent_LOGIN   UserEvent_EventType = 1
	UserEvent_LOGOUT  UserEvent_EventType = 2
)

var UserEvent_EventType_name = map[int32]string{
	0: "UNKNOWN",
	1: "LOGIN",
	2: "LOGOUT",
}
var UserEvent_EventType_value = map[string]int32{
	"UNKNOWN": 0,
	"LOGIN":   1,
	"LOGOUT":  2,
}

func (x UserEvent_EventType) String() string {
	return proto1.EnumName(UserEvent_EventType_name, int32(x))
}

type LoginRequest struct {
	Nick string `protobuf:"bytes,1,opt,name=nick" json:"nick,omitempty"`
}

func (m *LoginRequest) Reset()         { *m = LoginRequest{} }
func (m *LoginRequest) String() string { return proto1.CompactTextString(m) }
func (*LoginRequest) ProtoMessage()    {}

type LogoutResponse struct {
}

func (m *LogoutResponse) Reset()         { *m = LogoutResponse{} }
func (m *LogoutResponse) String() string { return proto1.CompactTextString(m) }
func (*LogoutResponse) ProtoMessage()    {}

type User struct {
	Nick         string `protobuf:"bytes,1,opt,name=nick" json:"nick,omitempty"`
	TimeLastSeen int64  `protobuf:"varint,3,opt,name=time_last_seen" json:"time_last_seen,omitempty"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto1.CompactTextString(m) }
func (*User) ProtoMessage()    {}

type Credentials struct {
	Nick  string `protobuf:"bytes,1,opt,name=nick" json:"nick,omitempty"`
	Token []byte `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *Credentials) Reset()         { *m = Credentials{} }
func (m *Credentials) String() string { return proto1.CompactTextString(m) }
func (*Credentials) ProtoMessage()    {}

type ListUsersResponse struct {
	Users []*User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
}

func (m *ListUsersResponse) Reset()         { *m = ListUsersResponse{} }
func (m *ListUsersResponse) String() string { return proto1.CompactTextString(m) }
func (*ListUsersResponse) ProtoMessage()    {}

func (m *ListUsersResponse) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type PrivateMsgRequest struct {
	Creds *Credentials `protobuf:"bytes,1,opt,name=creds" json:"creds,omitempty"`
	To    string       `protobuf:"bytes,2,opt,name=to" json:"to,omitempty"`
	Msg   string       `protobuf:"bytes,3,opt,name=msg" json:"msg,omitempty"`
}

func (m *PrivateMsgRequest) Reset()         { *m = PrivateMsgRequest{} }
func (m *PrivateMsgRequest) String() string { return proto1.CompactTextString(m) }
func (*PrivateMsgRequest) ProtoMessage()    {}

func (m *PrivateMsgRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

type PublicMsgRequest struct {
	Creds *Credentials `protobuf:"bytes,1,opt,name=creds" json:"creds,omitempty"`
	Msg   string       `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
}

func (m *PublicMsgRequest) Reset()         { *m = PublicMsgRequest{} }
func (m *PublicMsgRequest) String() string { return proto1.CompactTextString(m) }
func (*PublicMsgRequest) ProtoMessage()    {}

func (m *PublicMsgRequest) GetCreds() *Credentials {
	if m != nil {
		return m.Creds
	}
	return nil
}

type SendMsgResponse struct {
}

func (m *SendMsgResponse) Reset()         { *m = SendMsgResponse{} }
func (m *SendMsgResponse) String() string { return proto1.CompactTextString(m) }
func (*SendMsgResponse) ProtoMessage()    {}

type ChatServerMsg struct {
	// Types that are valid to be assigned to Msg:
	//	*ChatServerMsg_PublicMsg
	//	*ChatServerMsg_PrivateMsg
	//	*ChatServerMsg_UserEvent
	//	*ChatServerMsg_Heartbeat
	Msg isChatServerMsg_Msg `protobuf_oneof:"msg"`
}

func (m *ChatServerMsg) Reset()         { *m = ChatServerMsg{} }
func (m *ChatServerMsg) String() string { return proto1.CompactTextString(m) }
func (*ChatServerMsg) ProtoMessage()    {}

type isChatServerMsg_Msg interface {
	isChatServerMsg_Msg()
}

type ChatServerMsg_PublicMsg struct {
	PublicMsg *PublicMsg `protobuf:"bytes,1,opt,name=public_msg"`
}
type ChatServerMsg_PrivateMsg struct {
	PrivateMsg *PrivateMsg `protobuf:"bytes,2,opt,name=private_msg"`
}
type ChatServerMsg_UserEvent struct {
	UserEvent *UserEvent `protobuf:"bytes,3,opt,name=user_event"`
}
type ChatServerMsg_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,4,opt,name=heartbeat"`
}

func (*ChatServerMsg_PublicMsg) isChatServerMsg_Msg()  {}
func (*ChatServerMsg_PrivateMsg) isChatServerMsg_Msg() {}
func (*ChatServerMsg_UserEvent) isChatServerMsg_Msg()  {}
func (*ChatServerMsg_Heartbeat) isChatServerMsg_Msg()  {}

func (m *ChatServerMsg) GetMsg() isChatServerMsg_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *ChatServerMsg) GetPublicMsg() *PublicMsg {
	if x, ok := m.GetMsg().(*ChatServerMsg_PublicMsg); ok {
		return x.PublicMsg
	}
	return nil
}

func (m *ChatServerMsg) GetPrivateMsg() *PrivateMsg {
	if x, ok := m.GetMsg().(*ChatServerMsg_PrivateMsg); ok {
		return x.PrivateMsg
	}
	return nil
}

func (m *ChatServerMsg) GetUserEvent() *UserEvent {
	if x, ok := m.GetMsg().(*ChatServerMsg_UserEvent); ok {
		return x.UserEvent
	}
	return nil
}

func (m *ChatServerMsg) GetHeartbeat() *Heartbeat {
	if x, ok := m.GetMsg().(*ChatServerMsg_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ChatServerMsg) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), []interface{}) {
	return _ChatServerMsg_OneofMarshaler, _ChatServerMsg_OneofUnmarshaler, []interface{}{
		(*ChatServerMsg_PublicMsg)(nil),
		(*ChatServerMsg_PrivateMsg)(nil),
		(*ChatServerMsg_UserEvent)(nil),
		(*ChatServerMsg_Heartbeat)(nil),
	}
}

func _ChatServerMsg_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*ChatServerMsg)
	// msg
	switch x := m.Msg.(type) {
	case *ChatServerMsg_PublicMsg:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.PublicMsg); err != nil {
			return err
		}
	case *ChatServerMsg_PrivateMsg:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.PrivateMsg); err != nil {
			return err
		}
	case *ChatServerMsg_UserEvent:
		b.EncodeVarint(3<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.UserEvent); err != nil {
			return err
		}
	case *ChatServerMsg_Heartbeat:
		b.EncodeVarint(4<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Heartbeat); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ChatServerMsg.Msg has unexpected type %T", x)
	}
	return nil
}

func _ChatServerMsg_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*ChatServerMsg)
	switch tag {
	case 1: // msg.public_msg
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(PublicMsg)
		err := b.DecodeMessage(msg)
		m.Msg = &ChatServerMsg_PublicMsg{msg}
		return true, err
	case 2: // msg.private_msg
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(PrivateMsg)
		err := b.DecodeMessage(msg)
		m.Msg = &ChatServerMsg_PrivateMsg{msg}
		return true, err
	case 3: // msg.user_event
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(UserEvent)
		err := b.DecodeMessage(msg)
		m.Msg = &ChatServerMsg_UserEvent{msg}
		return true, err
	case 4: // msg.heartbeat
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Heartbeat)
		err := b.DecodeMessage(msg)
		m.Msg = &ChatServerMsg_Heartbeat{msg}
		return true, err
	default:
		return false, nil
	}
}

type PrivateMsg struct {
	To       string `protobuf:"bytes,1,opt,name=to" json:"to,omitempty"`
	From     *User  `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	Msg      string `protobuf:"bytes,3,opt,name=msg" json:"msg,omitempty"`
	TimeSent int64  `protobuf:"varint,4,opt,name=time_sent" json:"time_sent,omitempty"`
}

func (m *PrivateMsg) Reset()         { *m = PrivateMsg{} }
func (m *PrivateMsg) String() string { return proto1.CompactTextString(m) }
func (*PrivateMsg) ProtoMessage()    {}

func (m *PrivateMsg) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

type PublicMsg struct {
	From     *User  `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	Msg      string `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	TimeSent int64  `protobuf:"varint,3,opt,name=time_sent" json:"time_sent,omitempty"`
}

func (m *PublicMsg) Reset()         { *m = PublicMsg{} }
func (m *PublicMsg) String() string { return proto1.CompactTextString(m) }
func (*PublicMsg) ProtoMessage()    {}

func (m *PublicMsg) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

type UserEvent struct {
	Event UserEvent_EventType `protobuf:"varint,1,opt,name=event,enum=proto.UserEvent_EventType" json:"event,omitempty"`
	User  *User               `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Time  int64               `protobuf:"varint,3,opt,name=time" json:"time,omitempty"`
}

func (m *UserEvent) Reset()         { *m = UserEvent{} }
func (m *UserEvent) String() string { return proto1.CompactTextString(m) }
func (*UserEvent) ProtoMessage()    {}

func (m *UserEvent) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type Heartbeat struct {
}

func (m *Heartbeat) Reset()         { *m = Heartbeat{} }
func (m *Heartbeat) String() string { return proto1.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()    {}

func init() {
	proto1.RegisterEnum("proto.UserEvent_EventType", UserEvent_EventType_name, UserEvent_EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for UserService service

type UserServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*Credentials, error)
	Logout(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*LogoutResponse, error)
	ListUsers(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*ListUsersResponse, error)
}

type userServiceClient struct {
	cc *grpc.ClientConn
}

func NewUserServiceClient(cc *grpc.ClientConn) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*Credentials, error) {
	out := new(Credentials)
	err := grpc.Invoke(ctx, "/proto.UserService/Login", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Logout(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*LogoutResponse, error) {
	out := new(LogoutResponse)
	err := grpc.Invoke(ctx, "/proto.UserService/Logout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ListUsers(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	out := new(ListUsersResponse)
	err := grpc.Invoke(ctx, "/proto.UserService/ListUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserService service

type UserServiceServer interface {
	Login(context.Context, *LoginRequest) (*Credentials, error)
	Logout(context.Context, *Credentials) (*LogoutResponse, error)
	ListUsers(context.Context, *Credentials) (*ListUsersResponse, error)
}

func RegisterUserServiceServer(s *grpc.Server, srv UserServiceServer) {
	s.RegisterService(&_UserService_serviceDesc, srv)
}

func _UserService_Login_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(LoginRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Login(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserService_Logout_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Credentials)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).Logout(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserService_ListUsers_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Credentials)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UserServiceServer).ListUsers(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _UserService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _UserService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _UserService_Logout_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _UserService_ListUsers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for ChatService service

type ChatServiceClient interface {
	SendPrivate(ctx context.Context, in *PrivateMsgRequest, opts ...grpc.CallOption) (*SendMsgResponse, error)
	SendPublic(ctx context.Context, in *PublicMsgRequest, opts ...grpc.CallOption) (*SendMsgResponse, error)
	ListenForMessages(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (ChatService_ListenForMessagesClient, error)
}

type chatServiceClient struct {
	cc *grpc.ClientConn
}

func NewChatServiceClient(cc *grpc.ClientConn) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) SendPrivate(ctx context.Context, in *PrivateMsgRequest, opts ...grpc.CallOption) (*SendMsgResponse, error) {
	out := new(SendMsgResponse)
	err := grpc.Invoke(ctx, "/proto.ChatService/SendPrivate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) SendPublic(ctx context.Context, in *PublicMsgRequest, opts ...grpc.CallOption) (*SendMsgResponse, error) {
	out := new(SendMsgResponse)
	err := grpc.Invoke(ctx, "/proto.ChatService/SendPublic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) ListenForMessages(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (ChatService_ListenForMessagesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChatService_serviceDesc.Streams[0], c.cc, "/proto.ChatService/ListenForMessages", opts...)
	if err != nil {
		return nil, err
	}
	x := &chatServiceListenForMessagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChatService_ListenForMessagesClient interface {
	Recv() (*ChatServerMsg, error)
	grpc.ClientStream
}

type chatServiceListenForMessagesClient struct {
	grpc.ClientStream
}

func (x *chatServiceListenForMessagesClient) Recv() (*ChatServerMsg, error) {
	m := new(ChatServerMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ChatService service

type ChatServiceServer interface {
	SendPrivate(context.Context, *PrivateMsgRequest) (*SendMsgResponse, error)
	SendPublic(context.Context, *PublicMsgRequest) (*SendMsgResponse, error)
	ListenForMessages(*Credentials, ChatService_ListenForMessagesServer) error
}

func RegisterChatServiceServer(s *grpc.Server, srv ChatServiceServer) {
	s.RegisterService(&_ChatService_serviceDesc, srv)
}

func _ChatService_SendPrivate_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(PrivateMsgRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChatServiceServer).SendPrivate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChatService_SendPublic_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(PublicMsgRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChatServiceServer).SendPublic(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChatService_ListenForMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Credentials)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).ListenForMessages(m, &chatServiceListenForMessagesServer{stream})
}

type ChatService_ListenForMessagesServer interface {
	Send(*ChatServerMsg) error
	grpc.ServerStream
}

type chatServiceListenForMessagesServer struct {
	grpc.ServerStream
}

func (x *chatServiceListenForMessagesServer) Send(m *ChatServerMsg) error {
	return x.ServerStream.SendMsg(m)
}

var _ChatService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendPrivate",
			Handler:    _ChatService_SendPrivate_Handler,
		},
		{
			MethodName: "SendPublic",
			Handler:    _ChatService_SendPublic_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListenForMessages",
			Handler:       _ChatService_ListenForMessages_Handler,
			ServerStreams: true,
		},
	},
}
